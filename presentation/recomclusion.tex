\section{Recommendations}
\subsection{Recommendations}
\begin{frame}{Recommendations}
\begin{itemize}
    \item<1-> In this section, we discuss some of the limitations of our system, and propose various improvements to it.
    \item<2-> These improvements can be implemented by future researchers who plan to either continue this project, or create similar door access control systems.
    \item<3-> Improvements are classified into two categories:
    \begin{itemize}
    	\item<4-> Vital to use the system in a real world setting
    	\item<5-> Potentially useful as extra features.
	\end{itemize}
\end{itemize}
\end{frame}

\subsection{Core Functionality}
\begin{frame}{Communication with Door Lock}
\begin{itemize}
    \item<1-> When implementing the system, a door lock module needs to be installed in the Raspberry Pi.
    \item<2-> In the code, however, we have created a dummy door lock class which we give instructions to, like \texttt{lock} or \texttt{unlock}, so that future researchers will have less trouble implementing the real door lock class.
\end{itemize}
\end{frame}

\begin{frame}{Exit Button}
\begin{itemize}
    \item<1-> Since the SpoonPi controller is only installed outside the room, users who are inside the room need a way to mechanically disable the lock in order to leave the room.
    \item<2-> An exit button needs to be connected to the door lock, in order to temporarily unlock it when it is pressed.
    \item<3-> This can be implemented using pure hardware wiring; it does not necessarily have to pass through the SpoonPi unit.
\end{itemize}
\end{frame}

\begin{frame}{Power Supply}
\begin{itemize}
    \item<1-> In real world systems, we cannot assume that the power will be consistently on.
    \item<2-> Before a SpoonPi unit loses power, it must be able to unlock all doors, or else someone might get locked inside a room.
    \item<3-> To solve this problem, the SpoonPi must be connected to an emergency power supply, and know how much battery life is left.
    \item<4-> Such a power supply would enable SpoonPi to function even after a power outage, and determine when to release all door locks and shut down.
    \item<5-> Another potential improvement for the system is the use of Power Over Ethernet (PoE), so that only one cord needs to be attached to each Raspberry Pi unit. With this, we can provide power and transmit data over the same wire.
\end{itemize}
\end{frame}

\begin{frame}{Connectivity Indicator}
\begin{itemize}
    \item<1-> Like the power supply, we cannot assume that all SpoonPi units will always be able to connect to the ForkPi database.
    \item<2-> If network connectivity fails, then SpoonPi will not be able to query ForkPi for keypair matches, hence the whole system falls apart.
    \item<3-> If we cannot recover from a network failure, we should at least be able to release control of the lock, and communicate the disconnectivity to users.
    \item<4-> This can be done in the form of a LED light that is only on when it is connected to ForkPi.
\end{itemize}
\end{frame}

\subsection{Useful Improvements}
\begin{frame}{Cached Keypairs}
\begin{itemize}
    \item<1-> Should SpoonPi lose its connectivity with ForkPi, SpoonPi has no way of determining which keypairs are authorized, so it has to release the door lock.
    \item<2-> Instead of querying the ForkPi database for every transaction, it would be better for the SpoonPi to maintain its own copy of authorized keypairs, so that it can function after a network failure.
    \item<3-> This can be implemented as a cached database copy, which is periodically updated whenever SpoonPi is connected to ForkPi.
\end{itemize}
\end{frame}

\begin{frame}{ForkPi Hierarchy}
\begin{itemize}
    \item<1-> In our system, there is only one ForkPi unit in the entire network. This makes ForkPi a single point of failure. % (why?)
    \item<2-> It is possible to introduce a hierarchy of ForkPis, such that there is a Raspberry Pi unit (called KnifePi) that is dedicated to talking to ForkPis, while the ForkPis are the ones that talk to the SpoonPis.
    \item<3-> Each ForkPi must be able to stand on its own without the help of KnifePi, so that KnifePi does not become a single point of failure.
    \item<4-> ForkPi units can be connected to different networks, as long as KnifePi can reach all of them. For example, one ForkPi can be dedicated to each floor, and one KnifePi for the entire building.
\end{itemize}
\end{frame}

\begin{frame}{Data Backup and Restore}
\begin{itemize}
    \item<1-> Since the memory on the ForkPi's SD card is limited, we want to be able to permanently delete obsolete data in order to free up space.
    \item<2-> In the ForkPi web app, we already provided a way to export logs to CSV, and delete them from the database.
    \item<3-> However, there is no easy way to back-up keypairs to a file such that they can be restored later if the need arises. 
    \item<4-> Theoretically, this can be done by dumping the PostgreSQL database and restoring it, but we want to be able to do this inside the web app for convenience.
\end{itemize}
\end{frame}

\begin{frame}{Date and Time-based Permissions}
\begin{itemize}
    \item<1-> In some environments, users can be granted access through a door only at a certain time of the day, or on certain days of the week.
    \item<2-> When a keypair is linked to a door, it might be beneficial to be able to specify at which specific times the keypair is valid for that door.
    \item<3-> For example, students should only be allowed into classrooms when they have a class at that time.
\end{itemize}
\end{frame}

\begin{frame}{Realtime Log Analysis}
\begin{itemize}
    \item<1-> Our logging system allows admins to review the logs and check for intruders in the system. In a system with thousands of users, manually checking the logs will become infeasible.
    \item<2-> Ideally, intrusion detection should be automatically done. For example, if the same keypair was presented to two SpoonPis at around the same time, then one of them might have been an intruder, especially of the two SpoonPis are geographically far apart.
    \item<3-> The hardware components, like the Pi controller or the door knob, can also be checked for damage, since an intruder may try physically breaking the system in order to get in by force.
\end{itemize}
\end{frame}

\subsection{Conclusion}
\begin{frame}{Conclusion(1 of 2)}
\begin{itemize}
    \item<1-> Our system aims to provide cost-effective security to the public.
    \item<2-> Since all the system components can be easily bought from online stores, and we made the code open source, any user that wants to try out the system can build the system for themselves.
    \item<3-> While the door lock has not yet been integrated into the system, all other major functions are already in place, like determining whether to allow a user based on their input credentials, managing user permissions, and viewing and exporting logs.
\end{itemize}
\end{frame}

\begin{frame}{Conclusion(2 of 2)}
\begin{itemize}
    \item<1-> Communications are encrypted, and additional features such as lockouts are implemented in order to defend against attackers.
    \item<2-> When we presented the system, it was well-received, whether the person had prior experience with similar systems or not.
    \item<3-> We have shown that the system is both acceptably secure, and easy to understand and operate, while still costing less than most commercial products currently available in the market.
\end{itemize}
\end{frame}